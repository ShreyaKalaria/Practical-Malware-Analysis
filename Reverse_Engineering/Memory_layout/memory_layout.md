##  Memory Layout of a running Process.

##### Note: The concept is explained by taking a 64-bit executable. The addresses change significantly on a 32-bit machine but the concept is the same. 

This post discusses how are the components of a program(text/code, data section, local variables and more) are arranged in the memory space when the program is loaded for execution. 

### Introduction

* In a general C program, these are the things found.
	*	**main** function is compulsory. There is a text segment for sure.
	
	*	There could be **local variables** in the main function.
	
	*	There could be **global variables** in the program.
	
	*	If the main function needs some memory at run-time, it can allocate memory dynamically using **malloc()** or **calloc()**. 
	
These are the essentials found in a C program. These essentials  have to be arranged in someway when the program is loaded into memory and starts execution. These are arranged in a **very systematic** manner. 

The objective of this post is to understand what this systematic manner is in detail.

### What does the C program contain?
The list in Introduction was a rough one. We will make a proper effective list  of components.

*	A C program should have minimum of 1 function(**main function**) in normal cases. We can define as many functions as we want. This means, the program has the code of all the functions.

*	Every function can have it's own set of **local variables**.

*	There can be **global variables**( **initialized** and  **uninitialized**).

*	There can be **static variables**.

*	If any function requires memory at run-time, it can be allocated using **malloc()** or **calloc()**. This is Dynamic memory. 

*	When a process is created , it inherits all the **environment variables** of it's parent's environment..  

*	If the program is using Functions of Standard C library, it uses the **libc shared object** for dynamic linking.

These are the important components of a C program. The idea is to understand how all these components are arranged in the main memory once the program is loaded . 

### The memory-layout of a Linux Process

The memory layout looks something like this.
![memory_layout](./images/memory_layout.jpg)

1. **Text Segment** : 
		
	*	This segment consists of **machine code which is executed** when the program is loaded into memory. 
	
	*	This segment's starting address is the starting address of the whole program in memory. In 64-bit machines, the first address is always **0x400000**. 
	
	* Under normal conditions, this segment is a **read-only** segment. The instructions can only be read and executed, but not written/modified.(For security purposes).
	
	* Default Permission bits: (Read - no Write - Execute) or **r-x**.

2. **Data Segment** : 
	* This segment consists of **initialized** and **uninitialized** **global** variables. 
	
	* The Data segment is present right above the text segment.
	
	* Under normal conditions, the data stored here can be **read and written into**. Even if you consider these variables as instructions, you cannot execute it.-**non-executable**. 
	
	* Default Permission bits: **rw-**

3. **Heap** :  
	
	* This part of memory is present to cater to the process's **dynamic memory requests**. At runtime, process can use **malloc()**, **calloc()** in C, **new** in C++ to allocate memory at runtime. That memory is allocated in heap.
	
	* I was trying to find the reason why this part of memory is named as heap. 
		* First of all, there is **no** connection between this heap and the tree-heap data structure.
		
		* This heap is taken from the colloquial / general meaning of heap, like heap of clothes. Here heap is just a pile of random memory bytes that can be allocated.
		* Functions like malloc(), calloc() returns a **pointer** to the memory if memory is successfully allocated, and the heap grows **upward**. This simply means if you request for more memory at runtime, you get memory with larger starting addresses.
	
	* The heap is present above the Data Segment.
	* Default Permission bits: **rw-**

4. **Stack** :
	* Stack is the section of memory allocated to a process at **loadtime**. 
	
	* This memory is present to store **local variables**, to **control the flow** of a program(Calling Functions and returning back to the caller). 
	
	* The simplicity of stack is what made it to be the backbone of a process. The simple **push** and **pop** operations are more than sufficient to control the flow of the program.
	
	* The stack starts from the **highest** Address and grows **downward**. So, at any point the **top of the stack** will have the **lowest address**. This feels wierd and confusing at the beginning till the you get used to it.
	* **Stack frames** :
		*  The way a program gets executed is, at any point an instruction will belong to one or the other function.
		
		* If there are no new functions, then all instructions belong to the main function. 
		
		* There is method in which stack is used during execution of a program. 
		
		* The huge stack memory is **dynamically split** into what are known as **stack frames** . It is known as a frame as it has a well defined **top address** and **bottom address**. 
		
		* Every function has it's own stack frame. When a function(**callee function**) is called by the **caller function**, a **new stack frame is constructed** for the callee function. 
		
		* All those local variables of a function is stored in it's private stack frame.
		
		* When the callee function is returning the control back the caller function, the stack frame is destructed and that memory is freed .
		
	* Default Permission bits: **rw-**. 
	
	* The thorough explanation of stack will be part of a separate post, because there are hell lot of things to understand about the stack.
	
5. **Shared Libraries** : 
	* The most common shared library used by C programs is the **libc**, the Standard C library. 
	
	* You can easily make your own shared library also. 
	
	* If programs are compiled normally, then all the libc functions are linked dynamically at runtime.
	
	* The address space for all these shared libraries is between the **top of the stack**(remember stack grows downwards) and the **top of the heap**. 
	* Default Permission bits: **r-x**

Here is the memory layout image once again, if you are too lazy to scroll up :P
![memory layout](./images/memory_layout.jpg)

I hope you have understood the theory of memory layout of a running linux process.
Let us head to some practicals.

### Practicals

**1.** Understanding a simple C program's layout. 
 
* This is the [Link](./code_samples/code1.c) to the C program used in this post. The program has a **for(;;)** (an infinite loop) at the end for a reason.

	*  That is a simple program which prints the addresses of all the global variables, local variables, a heap address and address of a libc function.
![Output of code1.c](./images/code1.output.png)
	
	* Observe the addresses very carefully. The output will properly **coresspond** to the theory we discussed above. 
	
	* Notice that there is a problem with the **address of puts()** . That requires a deeper understanding of what dynamic linking is. I will write about it in another post. 

	I hope this example has given clear picture of the memory layout of a process.

**2.** The Linux Operating System has a very important directory known as the **proc** directory in the root directory. 

* The reason the directory is named **proc** is because it gives every single detail about all the processes running. It also contains many other details about the system.

* Every process has a unique **Process ID**(PID). Inside the proc directory, there will be directories named after processes' PIDs. We can go to the PID we want to check out the details of a particular process.

* Suppose a process is run and it terminates. The OS clears off the directory belonging to that process/PID. That is why there is an infinite loop in code1.c. The process runs for infinite time.  We can peacefully analyze the process.

* 	How to find the PID of a process?
	
	* First run the process in one terminal.
	
	* Open up another terminal.
	
	* **$ ps -e ** : This command will all the processes. Search for **code1**.
	![PID of code1](./images/code1.pid.png) 
	
	* The first number, 23377(in the above image) is the PID of code1 process.
	
	* You can do this to directly get the entry of code1.
		* **$ ps -e | grep "code1"** 
	
	* The PID changes everytime you run it and it might not be the same as the PID in the above image. 

* Now that we have the PID = 23377 with us, let us go to the proc directory.
![proc directory entry](./images/code1.procdirentry.png)

* There are many file and directories. Let us focus on the **maps** file.
![The maps file](./images/code1.insideproc23377.png)

* This is the screenshot of the maps file.
![code1.maps file](./images/code1.proc.maps.png)

* This file gives the address range of every segment. This is also known as **memory mapping** of every segment.
* **ANALYSIS** :
	
	* There are 6 columns in every entry. Let us focus on 3 of the columns and 4 of those multiple entries. 
		
		* First column - **Address range** of a particular segment.
		
		* Second column - **Permission** bits.
		
		* Last column - The **name** of the segment.
		
		* Other columns: These entries require some background to understand what they are and what they mean.
	
	* **First Entry** : **Text Segment**
		
		* The Address range is 0x400000 - 0x401000. This means, that all the code is present in this range. It can be read and executed. cannot write into this range.
		
		* It not only contains code that gets executed. It also has the **.rodata** segment where local read-only data is found.
		
	* **Second Entry** : **Read-Only part of Data Segment** 
		
		* Address range is 0x600000 - 0x601000. All the **global** read-only data is stored here.
		
		* This is a part of **Data Segment**.
	
	* **Third Entry** : **Read-Write Data segment**
		
		* Address range is 0x601000 - 0x602000. All global read-write data is stored here. 
		
		* Both initialized and uninitialized variables are present in this range.
	* **Fourth Entry** : **Heap**
		
		* Address range is 0x1f36000 - 0x1f57000 . 
		
		* This is the initial heap space allocated to the process. If it wants more, if memory is present, more space will be allocated.
	*  **Fourteenth Entry** : **Stack**
		
		* This is the stack address range.
	
If there is any doubt regarding a particular process, the **/proc** is the best place to search for the answer.

### Some interesting things about the layout

1. Why is the stack growing downwards and heap upwards? Why wasn't the layout designed the other way round?
	
	* The x86 architecture(Architecture of Intel processors) is designed to support the downward growth of stack. Read this excellent answer([Link](https://stackoverflow.com/questions/664744/what-is-the-direction-of-stack-growth-in-most-modern-systems/664779#664779)) on stackoverflow for this question.

2. Why is the address of puts() = 0x4004d0 though it is a part of the libc shared library?

* If the program is disassembled using **objdump** and the address 0x4004d0 is checked, there will be an entry **puts@plt** . This is not the actual **puts** function . You can just verify it by looking at the assembly code of puts@plt. 

* When the main function calls **puts()**, it calls puts@plt. The C library functions are relocated at runtime(Check out my previous post[Link])(../Internals_of_Compiling/internals_of_compiling.md) . **When puts@plt is called, it takes care of the relocation**.

* So, an address in the shared library section is assigned to puts() function by the system at runtime. 

* This can be verified if the program is run using a debugger.

3. If you keenly observe the **permission bits** of every segment, you can notice that there is never a permission like **-wx** or **rwx**. That is, there is no **write** and **execute** permissions both for a segment. There is a strong reason for that.
	
	* The software written for computers had a lot of security issues. If one of such security issue(known as a **vulnerability**) is found, it can potentially be used to execute any code the attacker wants. Ideally, a software is intended to work in a very well defined manner. But executing attacker's code obviously fall under that definition. 
	
	* A particular vulnerability known as **buffer overflow vuln** can be used to write code into the memory and execute it.
	
	* Suppose there is a **char buf[100]**. The vulnerability allows us to write the code we want into this buffer and then execute it. So, we are **writing** the code and **executing** it.(Check out my post on stack overflow)
	
	* These types of vulnerabilities never seemed to end in software. So, one of the very famous mitigation techniques is the **w^x** or **writeXORexecute**. This restricts a segment either to get executed or to be written. Both is not possible.
	
	* Now, even in the presence of such vulnerabilities, attackers cannot execute their code. 
	
	* In most of the *NIX systems, this mitigation technique is known as **w^x** technique. In MS Windows, it is known as **DEP / Data Execution Prevention**.
	
	*  This turned out to be an amazing technique. So, it was implemented in the hardware / processor level too. There is a **single bit** of information in the hardware known as **XD / Execute Disable** , also known as **NX / No Execute**. Intel people call it XD and AMD people call it NX. 
	
	* This was a very effective mitigation technique, but  at the moment, there are methods to bypass it.

4. Why are the addresses of stack and heap segments changing?
	
	* Similar to the above answer, this is a security measure taken to mitigate such executing attacker's code vulnerabilities(or **code-injection vulnerabilities**). 
	
	* Suppose the attacker is planning to store his code in that buf[100]. For him to figure out there is a security issue, and how to store his code, he will run the program/software several times. And finally, suppose he comes to a conclusion that he will store his code in buf[100]. So, once when he runs it, he will make a note of the address of the buffer.
	
	* The next time he runs the program, the address has changed :P. Now, obviously the old address is no more the address of buf[100]. Again he will make a note of this new address. If he runs it again, he will again a new address different from the previous one.
	
	* This way, the address-changing method(formally known as **ASLR/Address Space Layout Randomization**), will make it very hard for the attacker to store his code.
	
	* The Randomization is by default applied for **stack**, **heap** and **shared memory** regions. ASLR can be disabled completely or it can be partially applied to a few of those regions.
	
	* Brute forcing wont work against this randomization. It will take a lot of time. 
	
	* This is most effective in 64-bit machines because the addresses are huge and can be randomized even more.

5. What are the other entries in /proc/ids/maps?	

* There are entries like **libc-2.23.so** , **ld-2.23.so** and many more.
	* **ld-2.23.so**	: 
		
		* We have seen that **ld** is the Linker which links object files(Check out the Internals of Compiling post). 
		
		* A program contains functions used from shared libraries which will require dynamic linking.
		
		* ld-2.23.so is a Dynamic Linker. It will find all the shared libraries required by the program and links them to the program .
		
		* For more explanation, checkout the manpage. **$ man ld.so** .
	* **libc-2.23.so** :
		
		*  **libc** stands for Standard C library. But in ubuntu, you can find **glibc**, The GNU C Library, because it is the libc written by GNU.
		
		* The **.so** stands for **shared object**. It is an object file, but can be shared among processes.
		
		* As it is an object file, any function requires linking before it is used. Those functions used will be linked to the program and assigned an address in the address range specified for libc-2.23.so .
	
	* **[vsyscall]** and **{vdso]** : These contains routines required for a program running in user mode to change to kernel mode when required. They  try to speed up the performance of the whole process. 
	
	* There is a lot of explanation about this in the manpages. **$man vdso**

That is it for this post. I thoroughly enjoyed writing this post. I hope you enjoyed reading it and learnt something out of it :)






