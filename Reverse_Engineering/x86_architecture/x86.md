## The x86 and x86_64 Architecture

In this post, we will discuss basics of x86 assembly language.

### 1. What does "Architecture" mean?

There are 2 terms to be described. **Organization** and **Architecture**.
**Architecture**: This is the Hardware-Software Interface present to help programmers program the hardware/processor. The set of instructions[**Instruction Set**], the way you can address memory, data types, some exception mechanism etc., come under architecture. 
**Eg1** : In the Assembly Language used to program Intel Processors, there is an instruction **inc** used to increment a particular value by 1.
Syntax: **inc *register_name***	. 

**Organization** : This deals with how a particular instruction or addressing technique is **implemented** at the hardware level.
**Eg1** : The Assembly Language used to program Intel processors is also used to program AMD(Advanced Micro Devices) processors. Here, the set of assembly instructions used to program them is the same. But, how each instruction is implemented at the hardware level is different. The **inc** instruction could be **implemented differently** in the 2 processors .

What **architecture** does is, it **abstracts** (or covers up) the internal hardware implementation of each instruction and provides a stable, well defined interface in the form of an **Instruction Set** to the programmer. The programmer need not worry about the internals. 

**Organization** deals with how an instruction is implemented at the hardware level. It talks about which is faster, the inc implemented in Intel processors or AMD. 

**Eg2** : To multiply 2 numbers, there is an instruction called **mul**. 

*	Architecture tells the programmer that he/she can make use of this instruction instead of repeated addition. It also defines the syntax of the instruction.

* Organization talks about the internal algorithms, hardware design used by Intel , AMD to make the instruction possible. 

* To compare the speed of **mul** instruction between the Intel and AMD processors, we have to study the Organization/Internal structure of the processors.

I hope this has given some insight into what Architecture means.

In this post,  we will be discussing about **x86 ISA**(Instruction Set Architecture) or in short, x86 Architecture.

##### NOTE: x86 ISA is defined for 32-bit machines. This post will cover both x86 ISA and x86_64 / AMD64 ISA for 64-bit machines. 

### 2. What is x86 ?

#### Some history about Intel processors.

* **Intel 4004**: Intel's one of the first processors. **4-bit processor**.

* **Intel 8080** was an **8 - bit** microprocessor. 

* **Intel 8086**  - **16-bit** microprocessor. Intel provided an 
* **Instruction Set** to use Intel 8086. The 8080 was renamed to 808**6** because 8086 was a 1**6** bit microprocessor.

* **Intel 80186**, **Intel 80286** were also 16-bit processors which performed better than 8086.

* **Intel APX 432** was the first 32-bit microprocessor by Intel.(It was not the first 32-bit processor ever manufactured). This failed as a microprocessor.

* **Intel 80386** is a **32-bit** microprocessor. became very famous in the market.

* **Intel 80486** was the successor of 80386.

* Then can the Legendary **Intel 80586** or **Pentium**. 

* After that, a few 32-bit microprocessors which had organizational changes were released. 

* Soon after that, **64-bit** processors came into market.

The point to understand is, 8086 had a 16-bit Instruction Set. When Intel introduced 32-bit microprocessors, they came up with a 32-bit Instruction Set which is an **extension** of the older 16-bit Instruction Set.
So, 8086, 80186, 80286, 80386, 80486, 80586 are the series of microprocessors . Later, they named the Instruction Set as x86 ISA where **86** stands for actual 86 in that series, the **x** is like a variable there. 
In some places, x86 ISA is also known as i386 ISA. 

When 64-bit microprocessors were introduced, Intel produced the 64-bit extensions of the x86 ISA. Along with Intel, AMD also produced their own 64-bit Extensions. The AMD's extension was successfully accepted, and Intel's extension failed. That is why 64-bit ISA is commercially known as **AMD64**. The first place I observed this is when I was trying to download the Ubuntu ISO image. There was no Intel64 option there. there were only i386(32-bit) and AMD64(64-bit). The 64-bit ISA is also known as **x64**, **x86_64** ISA.


### 3. Von Neumann Architecture

It is very important to understand the **blueprint/architecture**(This architecture means the design) of a computer system(and not ISA), because it will help in understanding why a particular set of instructions are required.
This is the famous **Von-Neumann** Architecture, which is the design of most of the modern systems.
![Von-Neumann Arch](./images/von_neumann_arch.jpg)

The above images shows that

*	There is an **ALU**. This means, the system has Hardware which does  Arithmetic , Logical operations and  Bit Manipulation.So, there should be corresponding Instructions in the ISA through which we can use the ALU.
*	There is a connection between Memory Unit(RAM) and CPU. This means, there should be 
	*	Memory Access Instructions : which are required to **load values from main memory(RAM) and store back some values / results back to the main memory**.
	
	*	Instructions which support different addressing techniques.
	
	*	Some memory manipulation instructions.

* **Control Instructions** used to make function calls, returns, software interrupts etc., easier.

* There are many complex instructions in x86 ISA which help the programmer as he can accomplish more work with lesser lines of code.

* There are few microprocessors which support direct access of secondary memory. So, there will be instructions to use that facility. But most microprocessors would not support this access to secondary memory because it takes a huge toll on it's performance. Check this out [Link](https://cs.stackexchange.com/questions/48769/why-cant-cpu-access-secondary-memory?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa). In general, CPU / processor accesses Main memory, and there will be Hardware which will help in Secondary Storage Access.


With some important basics covered , the actual discussion about **x86 ISA** begins from here.

### 4. x86 and x86_64 ISA

Before moving to instructions, let us understand what a **Register** is .

**Register** :

*  A Register is a small storage space on the chip of the microprocessor. Generally, there will be multiple registers on the chip.

* As this present on the chip, the access time(time taken by the processor to read data stored in a particular register) is very less(Access speed is extremely high).

**a]** The **x86** Architecture has **8** Registers, each of size **4-bytes** . They are

* **eax** : The **a** stands for **accumulator**. An accumulator is a register which is used to store results of certain operations(Like return value of a function is stored in eax)

* **ecx** : **c** stands for **counter**. It can be used as a counter in loops. 

* **edx** : **d** stands for **data**.

* **ebx** : **b** stands for **Base**. This is the Base Register. A Base value for a particular operation can be stored in ebx.

* **esi** : **Source** in string operations 
* **edi**: **Destination** in string operations

* **ebp**: **Base** Pointer

* **esp**: **Stack** Pointer

These registers known as (**GPRs / General Purpose Registers**) though ebp and esp are almost never used for general purposes. They have a specific purpose.

Along with these registers, there are 2 more special purpose known as  **eip** / **Instruction Pointer** and **eflags** . 

**b]** The **x86_64** architecture has **16** General Purpose registers each of size **8 bytes**.
	
* They are **rax**, **rcx**, **rdx**, **rbx**, **rsp**, **rbp**, **rsi**, **rdi**, **r9**, **r10**, **r11**, **r12**, **r13**, **r14**, **r15**. This register ordering is important.

* The first 8 registers are direct 64-bit extensions of their corresponding 32-bit registers. There are 8 new Registers introduced to the ISA.

* There are special purpose registers like **rip** and **rflags**.

**Note**: 

* When 8-bit microprocessors came into market, the name of the processors were **a**, **b**, **c**, **d** . 

* They renamed them as **ax**, **bx**, **cx** and **dx** for 16-bit microprocessors. the **x** stands for e**x**tended. 

* Then again when 32-bit microprocessors came, the 16-bit Instruction Set was extended. The **e** in any of those 32-bit registers means **e**xtended.

* The **r** simply stands for **r**egister.

![pseudo_registers](./images/pseudo_registers.jpg)

* There are instructions(for legacy / backward compatibility) which are used to access the **lower 32-bits** , **lower 16-bits** and the **upper 16-bits of lower 32-bits** of all the registers.

* The **eflags** is a set of **status bits**. Each flag has a value of 0(cleared/not set) or 1(set). Important flags are
	* **zf**: The zero flag. This is set when the result of an operation is zero. Else, it is cleared.
	* **cf**: The carry flag. This is set when the result of an operation is too small or too large for the destination operand. Else, it is cleared.
	* **sf**: The sign flag. This is set when the result of an operation is negative. It result is positive, it is cleared. It is the same as the **most-significant bit** of the result(2's complement representation).
	* There are many flags. This [webpage](http://www.c-jump.com/CIS77/ASM/Instructions/I77_0070_eflags_bits.htm) gives details about every flag.

* The **eip**(**rip** in x64): **Instruction Pointer**. 
	* This register stores the Address of the next instruction to be executed.
	* This register is of great importance for security folks, because in the presence of certain security vulnerabilities, the bad guy can **gain control** of eip and execute his/her code.  

*  Apart from all these registers, there is one more set of registers known as **Segment Registers**. They were introduced in microprocessors to implement a **memory-management technique**, which is now **not** used because of a better and amazing technique known as **paging**. 
	* The segment registers present (in both 32-bit and 64-bit processors) are 
		* **cs**: Code Segment
		* **ds**: Data Segment
		* **ss**: Stack Segment
		* **es**: Extra Segment
		* **fs** and **gs**: Extra segment registers which are used for special purposes. **f** and **g** are simply kept because in 16-bit processors, there were ss, **c**s, **d**s, **e**s. They added 2 more registers and named them fs and gs(like c,d,e,f,g). 
		* In 64-bit processors, as segmentation is not used, cs , ds , ss , es are forced to 0. But **fs** and **gs** are used for special purposes by the OS. So, they may be non-zero.

	  











































 






















 
