section .data

str: db "Hello world", 0x0a, 0x00		;Defined str
str_len: equ $-str				;str_len = Length of string str
	
section .text
	global _start

_start:
	mov rax, 0x04		; 0x04 is the system call number for write()
	mov rbx, 0x01		; 0x01 is the file descriptor for STDOUT
	lea rcx, [str]		; Load Address of string str
	mov rdx, str_len	; Load the length of string
	int 0x80		; Issue a software interrupt

	mov rax, 0x01		; 0x01 is the system call number for exit()
	mov rbx, 0x00		; 0 is the argument for the syscall
	int 0x80		; Issue a software interrupt


; EXPLANATION OF THE PROGRAM
;
;>> In section .data, there are 2 variables. str points to the string. str_len point the length of the string.
;
;>> In section .text, _start function is "compulsory".
; 
;1. The linker will search for this function as this is the entry point of any executable.
;
;2. How is a system call executed?
;
;a. The "system call number" is loaded into "rax" register.
;b. First argument of the system call is loaded into "rbx"
;c. Second into "rcx"
;d. Third into "rdx"
;e. If there are more arguments, they would go into rdi, rsi.
;
;f. int 0x80 : int stands for interrupt. 0x80 is the interrupt vector table entry.So, the handler at the 0x80th entry should be invoked.
;
;Eg:
;
;Example 1:
;a. The first int 0x80 executes the write() system call. 
;b. Syntax of the C wrapper function for write is -> write(int fd, void *buf, unsigned int no_of_bytes).
;c. First argument is file descriptor. We want to write "Hello world" onto stdout => fd = 1. So, mov rbx, 0x01
;d. Second argument is pointer to buffer. Our string is pointed by "str". So, lea rcx, [str]
;e. Third argument is number of bytes to be written. We want the whole string to be written.So, mov rdx, str_len
;f. int 0x80	: Asking kernel to handle this system call.
;
;
;Example 2:
;a. The second int 0x80 executes exit(0) system call. 
;I think the rest is self-explanatory.

