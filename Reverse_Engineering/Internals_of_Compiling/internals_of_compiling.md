## How is a C/C++ program converted to an executable?

##### Note: I will be explaining the concept on a 64-bit machine.The addresses mentioned in the later part of the post is specific to a machine. The Addresses are entirely different for a 32-bit machine. But the concepts are the same. 

This is the  [Link](./code_samples/code1.c) to the sourcecode of C program used.
![code1.c Image](./images/code1.c.sourcecode.png)

#### 1. An Overview of the whole conversion process.

* The **gcc** compiler takes the C sourcefile as an argument and **generates** an executable file. 


* This is how the executable file looks like:
  ![Inside an Executable file](./images/executable_file.png)
* The conversion of the C Sourcecode(**.c files**) to Machine code(**executable files**) is **not** a single step process. It consists of multiple steps.
![Conversion Process](./images/process_of_generating_executablefile.png)

The objective of this post is to understand every single step in detail.

It would be really easy to understand each step if the C sourcecode is compiled in the following manner.

**$ gcc code1.c -o code1 -save-temps**

This will not only generate **code1**( the executable ) but will also save the files created during the conversion process which will normally be deleted, but they help in our analysis, so we will save them.

There are 4 file totally generated. **hello.i** , **hello.s** , **hello.o** , **hello** .


#### 2. Generating the code1.i file and C Pre-Processor.
* [Link to code1.i file](./code_samples/code1.i)

* First of all, the **i** in code1.i stands for **intermediate**. 

* The **C Pre-Processor** ( cpp ) takes the normal code1.c file as input and generates code1.i as output. 

* The Job of the Pre-Processor is to expand all the header files included in C sourcefile. In code1.c, the only header file included is the **stdio.h** .So, that is expanded completely in the code1.i file.

* All the header files can be found in **/usr/include** directory.

* The meaning of **expansion** of a header file in C sourcefile is just copying the that header file found in /usr/include location into the C sourcefile.

* Compare the [stdio.h](/usr/include/stdio.h) and [code1.i](./code_samples/code1.i) .

* The header file mainly consists of these things:
  	* The Header files it would have included.
 
  	* A few typedefs of original datatypes (like unsigned int) into opaque datatypes(like pid_t, uid_t).
  	* A few important data structures relevant to the header file. Eg: The header file **/usr/include/net/ethernet.h**, has the structure of the ethernet header.
  	* Declaration of functions pertaining to the header file. Eg: stdio.h consists of declaration of all the functions which help in Input and Output of Data.

* The code1.i file still has the code the programmer has written.
![Click of code1.i](./images/code1.i.image.png)

#### 3. Generating the code1.s file and our Compiler.
* [Link to code1.s](./code_samples/code1.s)

* There could be a misunderstanding that the compiler converts C sourcecode to machine code.But the truth is Compilation is just a single step(**but a very important one though**) where, the **Compiler takes in code1.i as input and generates the code1.s file**.

* The **s** in code1.s stands for **source** file. Because code1.s is the the complete assembly equivalent of our C sourcefile. 

* Any compiler optimization technique used will be directly reflected on the assembly code.(And then obviously on the files generated at later stages).

* Here is a screenshot of the main function in code1.s .
![code1.s Screenshot](./images/code1.s.image.png)

* The machine I am using is a 64-bit Intel machine.The assembly language which can be understood by this machine is the **x86_64 assembly language**. So, the compiler generates the assembly code in x86_64 language.


* **Unlike** the way we have 1 C Programming Language, every processor in the market has a different **architecture** and is designed to understand a specific assembly language. So, that way , there are many assembly languages, each present to run on a specific processor. There cannot be 2 entirely different assembly languages for the same processor. Examples for processors and their assembly languages are 
  	* Intel's core i7 - x86_64 assembly language.
  
  	* Intel's Pentium - x86 assembly language.
  	
  	* IBM's PowerPC - ppc , ppc64 assembly language.
  	
  	* Oracle's Sparc - SPARC assembly language
  and many more.

* If we we have a ppc assembly sourcefile, it can run only on a PowerPC machine and it **cannot** run on Intel Processors.

* We have the code1.s in our hand now.

#### 4. Generating the code1.o file and the assembler.
* [Link to code1.o](./code_samples/code1.o)

* The **o** in code1.o stands for **object**. code1.o is known as an **object file**.
* The system program which takes in the assembly sourcefile and generates the object file is the **assembler**. 
* The assembler converts (or **assembles**) the assembly sourcefile to give an object file.
* The object file has pure machine code of the C sourcecode in it. 
![Screenshot of code1.o](./images/code1.o.image.png)

##### Analysis of the object file with objdump.
* Essentially, we cannot make any solid conclusions just by looking at the object file. So, Let us use the **objdump** (object dump) to see what is inside the file. This is how you use the Tool.
**$ objdump -Mintel -D code1.o > code1.o.objdump**

* [Link to code1.o.objdump](./code_samples/code1.o.objdump) 

* From the code1.o.objdump, we come to know that there are sections like **.text**, **.data**, **rodata**, **.comment**, **.ehframe**. Let us focus on the first 3.

* **.text section** : 
  * This section consists machine code of our main function. In general this section consists of machine code of all functions written in C sourcefile.

* **.data section** :
  * This section consists of Global and static variables.

* **.rodata section** : 
  * This section consists of all the **read-only(ro)** data . In our example, the **Hello world!!\n** is the only read-only element. So, it is stored in this section.

* Other sections are metadata required for the next stage.

* **NOTE** : 
  * Every instruction and section should have an address right? But here all the sections are starting with address **zero**.
  
  * There is no global uninitialized variables here in the object file.**But it is required right?**

  * The data present in .rodata section cannot be executed by the processor.(It is read-only, non-executable, non-writable data). The tool has simply converted the data into it's assembly equivalent, but these assembly instructions never get executed.

  * There are no **local variable names** like **c** and **d** in our example. 

  * There is no mention of **printf** function in the .text section. But note that there is **call** instruction.  

  * And there are more but these are the important ones.

##### Analysis of the object file with readelf.
* To clarify few of the problems mentioned above, we will use one more tool called **readelf** .

* [Link to code1.o.readelf](./code_samples/code1.o.readelf)

* **ELF** : stands for **Executable and Linkable Format**. For now, it is enough to know that any file which we want to execute on a Linux machine must be in this format.A file of any other format cannot be run even if it has machine code in it. Similar to ELF, Windows has it's own executable format. It is known as **PE( Portable Executable )** file format. 

* There is too much information in the readelf's output. We will focus on important ones.
  * The type of this file is **REL / Relocatable File** . This simply means that there are no absolute addresses given to the code and data in this file, they can be given any address / relocated in the right manner to give an executable. So, **All .o files are relocatable files.**
  
  * Let us go the the **Relocation Section**. 
  ![relocation section](./images/code1.o.relocation.png)
    * Totally, there are 3 entries. **.rodata** , **puts**, and the **.text**.
    
    * By our previous definition of Relocation, All these are in the relocation section because they have to be given absolute addresses.
  
  * Let us head straight to the last thing in the readelf output. The **Symbol table**.
  ![symbol Table](./images/code1.o.symboltable.png)
    * The present symbol table has 13 entries. The important entries are entry 9 ,10, 11, 12. 
  
    * They are entries of the 2 global variables, and 2 functions - main and puts.
    * Note that the size and type of variables a, b and function **main** are defined. Details about **puts** is unclear. We know that it is the print function used. But the system still does not know that.
  
* So after all this analysis, these are the conclusions made.
  
  * The Relocation Entries have to relocated / given absolute addresses to form an executable.
  
  * We did not see the names of the local variables anywhere in the object file or readelf. 
 
  * There is full information about **main**, and 2 global variables. 
  
  * The object file just knows that there is something called **puts** but does not know where it is, it's type, it's size and all that.

So, we have rectified a few problems of assembler stage, but not rectified all of them and a few new ones have come up(relocation and finding where puts is).

#### 5. Generating code1(executable) using linker.

* The last component is linker. **Linker** is a System program which takes one or more object files(those pure machine code files with no absolute addresses) and Libraries(like Standard C library) as input and if Linking is successful, generates an executable file.

* The Linker links the symbols(in the symbol table) to their definition(ie., main is defined in .text section, offset = 0).So, the symbol **main** is linked to that .text section, offset = 0). Then how and what will it link **puts** to? because we never defined puts anywhere.

* Linker also relocates / gives absolute addresses to every section in the object file, thus making it a complete Executable file.

* Analyzing the complete executable **code1**.
[Link to code1.readelf](./code_samples/code1.readelf)
  
  * The file type of **code1** is **EXEC** / **Executable file**.
  
  * Again there is too much data here. Let us focus only on what happened to our **puts** function.
  ![Dynamic symbol table of code1](./images/code1.dynamicsymboltable.png)
  
  * The above is a symbol table(similar(but not same) to one we found while analyzing code1.o file)
 
  * Coming to the last problem we have, the **puts** problem. It has been declared in the header file **stdio.h** (check it out), but no where it is defined. So, this is what happens. 
	  * The Standard C Library has the definitions of all the functions defined in those header files.  So, when the function is called(during the execution of the program), the function is given an absolute address on the fly and then executed. So, this is known as **Dynamic Linking**. Because, linking happens when the function is called.
	  
	  * Any C sourcecode compiled normally will link all the Standard C Libraru functions dynamically.
	
#### Analyzing code1(executable) using objdump.
* **$ objdump -Mintel -D code1 > code1.objdump**

* [Link to code1.objdump](./code_samples/code1.objdump)
  ![Main function from objdump](./images/code1.objdump.main.png)
 
 * The **main** function has been given an address of **0x400526** by the **linker**. 
 
 * At Address **0x40053e**, there is an instruction **call 0x400400 <puts@plt>**. For now, let us call 0x400400 as the Address of puts function(But actually, it is not. It needs more explanation). The point is, the **puts** is relocated.

This is is how a C Sourcefile is converted into an executable file.

#### A few more interesting things.

1. If there is only once C sourcefile like code1.c, the above explanation is enough. But huge projects will have multiple C sourcefiles. How is that situation handled?
	[Link to source1.c](./code_samples/source1.c)</br>
	[Link to source2.c](./code_samples/source2.c)</br>
	[Link to source1.i](./code_samples/source1.i)</br>
	[Link to source2.c](./code_samples/source2.i)</br>
	[Link to source1.o](./code_samples/source1.o)</br>
	[Link to source2.o](./code_samples/source2.o)</br>
	[Link to source](./code_samples/source)
	
	* **$ gcc source1.c source2.c -o target -save-temps**
	
	*	So, every C sourcefile is taken, independently converted into their respective object files.
	
	*	So, if there are 10 C sourcefiles, there will be 10 object files at the end of assembler stage.
	
	*	The **Linker** takes all the 10 object files and then if linking is successful, a single executable is generated.
	
	*	In the given example, there are 2 source files **source1.c** and **source2.c**. 

	This is how an executable is generated when there are multiple source files.

2. What our C program does solely depends on the **main** function. The Address of **main** function in code1 = 0x400526. So, it is natural that as soon as the program is loaded, the **main** starts to execute. ie., 0x400526 is the entry point of the program. But according to readelf tool, the Address of entry point of code1 = 0x400430. So, what is happening here?
![Start Address of main function](./images/code1.addressofmain.png)
![Entry point of code1](./images/code1.entrypoint.png)

	*	If checked, the address 0x400430 is the Address of a function called **_start**. This function does some initialization tasks before calling main.

	*	So, from a programmer's perspective, the entry point is main. From the OS point of view, the entry point is _start.

	*	This being said, there can be programs without the main function.
	
	*	It is important to know this because, when programs are written in assembly language, the Linker will be searching for it. 

3. The **gcc** will combine all the stages and just gives the executable. But every stage can be done manually.
	* This is how you do it.
		
		*	**$ gcc code1.c -E > code1.i** : This will stop the process after Pre-processing and will generate the code1.i file.
		
		*	**$ gcc code1.i -S** :  This will compile code1.i file to generate code1.s file.
		
		*	**$ as code1.s -o code1.o** : **as** stands for **assembler**. as assembles code1.i to give code1.o object file.
		
		*	**$ gcc code1.o -o code1** : Here only the linker works on code1.o to generate code1
		
4. When programs are written in assembly, only assembler and linker come into place.

	* The below link is a hello world program written in assembly.
[Link to hello.asm](./code_samples/hello.asm)
	
	* The **_start** function is compulsory. If it is not there, then the linker chooses a suitable Address as the _start function.
	
	* To generate an executable, the **nasm** assembler(an awesome,opensource assembler) and **ld** - the default linker are used.
		* **$ nasm hello.asm -f elf64**
		
		* **$ ld hello.o -o hello**
	
	* If there was no **start** symbol, the ld chooses a location as the beginning of _start function.


That is it for this post. I hope this post helps you understand how an executable is generated. I thoroughly enjoyed writing it. Hope you enjoy reading it :)
